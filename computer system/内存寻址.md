### 内存地址

程序员使用 **内存地址(memory address)** 访问内存单元，我们必须区分三种单元：

* 逻辑地址(logical address)：每一个逻辑地址都由一个段(segmenr)和偏移量(offset或displacement)组成，偏移量指明了从段开始的地方到实际地址之间的距离。
* 线性地址(linear address)(也称虚拟地址viritual address)：是一个32位无符号整数，线性地址通常用十六进制数字表示，值的范围从0x00000000到0xffffffff。
* 物理地址(physical address)用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示。

![[转换图.png]]

在x86保护模式下，段的信息（段基线性地址、长度、权限等）即**段描述符**占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而**段寄存器存放的是段描述符在GDT或LDT内的索引值**(index)。

**Linux中逻辑地址等于线性地址**。Linux所有的段（用户代码段、用户数据段、内核代码段、内核数据段）的线性地址都是从 0x00000000 开始，长度4G，这样 线性地址=逻辑地址+ 0x00000000，也就是说逻辑地址等于线性地址了。

这样的情况下**Linux只用到了GDT**，不论是用户任务还是内核任务，都没有用到LDT。GDT的第12和13项段描述符是 __KERNEL_CS 和__KERNEL_DS，第14和15项段描述符是 __USER_CS 和__USER_DS。内核任务使用__KERNEL_CS 和__KERNEL_DS，所有的用户任务共用__USER_CS 和__USER_DS，也就是说不需要给每个任务再单独分配段描述符。内核段描述符和用户段描述符虽然起始线性地址和长度都一样，但DPL(描述符特权级)是不一样的。__KERNEL_CS 和__KERNEL_DS 的DPL值为0（最高特权），__USER_CS 和__USER_DS的DPL值为3。


在多处理器系统中，所有CPU都共享同一内存，这意味着RAM芯片可以由独立的CPU并发地访问。因为在RAM芯片上的读或写操作必须串行地执行，因此一种所谓 **内存仲裁器(memoryarbiler)** 的硬件电路插在总线和每个RAM芯片之间。其作用是如果某个RAM芯片空闲，就准予一个CPU访问，如果该芯片忙于为另一个处理器提出的请求服务，就延迟这个CPU的访问。即使在单处理器上也使用内存仲裁器，因为单处理器系统中包含一个叫做DMA控制器的特殊处理器，而DMA控制器与CPU并发操作。从编程观点看，因为仲裁器由硬件电路管理，因此它是隐藏的。


逻辑地址：是相对于段而言的，需要段描述符和段内偏移来组成。所有段都从0x00000000开始，只需关注段内偏移即可。而段内偏移的值恰好等于线性地址的值。  

线性地址：是进程使用的地址，虚拟的地址。人为抽象出一大片地址空间给进程使用，为了方便32位地址总线存取，linux内核定义为了4G。  

物理地址：是采用32位总线存取物理内存某个字节时，地址总线上电位的高低。  
  
分段单元将逻辑地址转换成线性地址，分页单元将线性地址转换成物理地址。
## 分段

Intel微处理器以两种不同的方式执行地址转换，这两种方式分别称为 **实模式(real mode)** 和 **保护模式(protected mode)** 。

### 实模式

在 [Real Mode](https://wiki.osdev.org/Real_Mode "Real Mode") 中，使用 A：B 形式的逻辑地址来寻址内存。使用等式将其转换为物理地址：

```
Physical address = (A * 0x10) + B
```

纯实模式下的 (寄存器)registers 限制为 16 位以进行寻址。16 位可以表示 0 到 64k 之间的任何整数。这意味着，如果我们将 A 设置为固定值并允许 B 更改，我们可以寻址 64k 的内存区域。这个 64k 区域称为段。很明显，区段可以重叠。

```
A = A 64k segment B = Offset within the segment
```


### 段选择符和段寄存器

逻辑地址由两部分组成:一个段标识符和一个指定段内相对地址的偏移量。段标识符是一个16位长的字段，称为段选择符(Segment Selector)如图所示，而偏移量是一个32位长的字段。

| 15                                3 | 2      | 1        0 |
| ----------------------------------- | ------ | ---------- |
| **Index**                           | **TI** | **RPL**    |

- **Index:** 选择器引用的 **GDT** 或 **LDT** 条目索引的第 3-15 位。由于 **[Segment Descriptors](https://wiki.osdev.org/Global_Descriptor_Table#Segment_Descriptor "Global Descriptor Table")** 的长度为 8 字节，因此 **Index** 的值永远不会未对齐，并且包含最低 3 位中的所有零。
- **TI:** 指定要使用的描述符表。如果清除 **0**，则使用 **GDT**，如果设置为 **1**，则使用当前 **LDT**。
- **RPL:** 选择器请求的 **[Privilege Level](https://wiki.osdev.org/Security#Rings "Security")** （权限级别） 确定选择器在权限检查期间是否有效，并且可以设置执行或内存访问权限。

**Segment Selector** 是特定于 [IA-32](https://wiki.osdev.org/IA32_Architecture_Family "IA32 Architecture Family") 和 [x86-64](https://wiki.osdev.org/X86-64 "X86-64") 架构的 16 位二进制数据结构。它在 [保护模式](https://wiki.osdev.org/Protected_Mode "Protected Mode")和[长模式下](https://wiki.osdev.org/Long_Mode "Long Mode")  使用。其值标识  [Global Descriptor Table](https://wiki.osdev.org/Global_Descriptor_Table "Global Descriptor Table") 或 **[Local Descriptor Table](https://wiki.osdev.org/Local_Descriptor_Table "Local Descriptor Table")** 中的段。它包含三个字段，并在各种情况下用于与 **[Segmentation](https://wiki.osdev.org/Segmentation "Segmentation")** 交互。

![[逻辑地址到线性地址的变换过程.png]]

x86 系列计算机有 6 个段寄存器（CS、DS、ES、FS、GS、SS）。它们彼此完全独立。

| CS  |                  Code Segment   代码段                   |
| --- | :---------------------------------------------------: |
| DS  |                     Data Segment                      |
| SS  | [Stack](https://wiki.osdev.org/Stack "Stack") Segment |
| ES  |                     Extra Segment                     |
| FS  |               General Purpose Segments                |
| GS  |               General Purpose Segments                |

cs寄存器还有一个很重要的功能:它含有一个两位的字段，用以指明CPU的当前特权级(CurrentPrivilegeLevel，CPL)。值为0代表最高优先级，而值为3代表最低优先级。Linux只用0级和3级，分别称之为内核态和用户态。

### 段描述符

每个段由一个8字节的段描述符(Segment Descriptor)表示，它描述了段的特征。段描述符放在全局描述符表(Global Descriptor Table,GDT)或局部描述符表(Local Descriptor Table ,LDT)中。
![[段描述符通用格式.png]]

- BASE(32位)：段首地址的线性地址。
    
- G：为0代表此段长度以字节为单位，为1代表此段长度以4K为单位。
    
- LIMIT(20位)：此最后一个地址的偏移量，也相当于长度，G=0，段大小在1~1MB，G=1，段大小为4KB~4GB。
    
- S：为0表示是系统段，否则为代码段或数据段。
    
- Type：描述段的类型和存取权限。
    
- DPL：描述符特权级，表示访问这个段CPU要求的最小优先级(保存在cs寄存器的CPL特权级)，当DPL为0时，只有CPL为0才能访问，DPL为3时，CPL为0为3都可以访问这个段。
    
- P：表示此段是否被交换到磁盘，总是置为1，因为linux不会把一个段都交换到磁盘中。
    
- D或B：如果段的LIMIT是32位长，则置1，如果是16位长，置0。(详见intel手册)
    
- AVL：忽略。

**数据段描述符：** 表示这个段描述符代表一个数据段，这种描述符可以放在GDT或者LDT。该描述符的S标志位为1，也就是非系统段。需要注意内核数据段属于数据段描述符，并不属于系统段描述符。
**代码段描述符：** 表示这个段描述符代表一个数据段，这种描述符可以放在GDT或者LDT。该描述符的S标志位为1，也就是非系统段。需要注意内核代码段属于代码段描述符，并不属于系统段描述符

![[代码段、数据段和系统段描述符格式.png]]

### **全局描述符表与局部描述符表**

　全局描述符表和局部描述符表保存的都是段描述符，记住要把段描述符和段选择符区别开来，保存在寄存器中的是段选择符，这个段选择符会到描述符表中获取对于的段描述符，然后将段描述符保存到对应寄存器的非编程寄存器中。

　系统中每个CPU有属于自己的一个全局描述符表(GDT)，其所在内存的基地址和其大小一起保存在CPU的gdtr寄存器中。其大小为64K，一共可保存8192个段描述符，不过第一个一般都会置空，也就是能保存8191个段描述符。第一个置空的原因是防止加电后段寄存器未经初始化就进入保护模式而使用GDT。

　而对于局部描述符表，CPU设定是每个进程可以创建属于自己的局部描述符表(LDT)，当前被使用的LDT的基地址和大小一起保存在ldtr寄存器中。不过大多数用户态的liunx程序都不使用局部描述符表，所以linux内核只定义了一个缺省的LDT供大多数进程共享。描述这个局部描述符表的局部描述符表描述符保存在GDT中

因此，我们便可以通过以下关系，进行寻址：

![[段描述符表结构.png]]

![[linux 主要段.png]]
## 分页



