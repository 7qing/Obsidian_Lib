
## 什么是中断？

我们将会从下面的主题开始：

- 什么是 `中断（interrupts）` ？
- 什么是 `中断处理（interrupt handlers）` ？

	中断就是当软件或者硬件需要使用 CPU 时引发的 `事件（event）`。比如，当我们在键盘上按下一个键的时候，我们下一步期望做什么？操作系统和电脑应该怎么做？做一个简单的假设，每一个物理硬件都有一根连接 CPU 的中断线，设备可以通过它对 CPU 发起中断信号。但是中断信号并不是直接发送给 CPU。在老机器上中断信号发送给 [PIC](http://en.wikipedia.org/wiki/Programmable_Interrupt_Controller) ，它是一个顺序处理各种设备的各种中断请求的芯片。在新机器上，则是[高级程序中断控制器（Advanced Programmable Interrupt Controller）](https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller)做这件事情，即我们熟知的 `APIC`。一个 APIC 包括两个独立的设备：
	- `Local APIC`
	- `I/O APIC`
	第一个设备 - `Local APIC` 存在于每个CPU核心中，Local APIC 负责处理特定于 CPU 的中断配置。Local APIC 常被用于管理来自 APIC 时钟（APIC-timer）、热敏元件和其他与 I/O 设备连接的设备的中断。
	
	第二个设备 - `I/O APIC` 提供了多核处理器的中断管理。它被用来在所有的 CPU 核心中分发外部中断。更多关于 local 和 I/O APIC 的内容将会在这一节的下面讲到。就如你所知道的，中断可以在任何时间发生。当一个中断发生时，操作系统必须立刻处理它。但是 `处理一个中断` 是什么意思呢？当一个中断发生时，操作系统必须确保下面的步骤顺序：
	- 内核必须暂停执行当前进程(取代当前的任务)；
	- 内核必须搜索中断处理程序并且转交控制权(执行中断处理程序)；
	- 中断处理程序结束之后，被中断的进程能够恢复执行。



## 可编程中断控制器(PIC、APIC)

### 中断控制器

中断控制器是作为中断(IRQ)和CPU核之间的一个桥梁而存在的，每个CPU内部都有一个自己的中断控制器，中断线并不是直接与CPU核相连，而是与CPU内部或外部的中断控制器相连。而为什么叫做可编程中断控制器，是因为其本身有一定的寄存器，CPU可以通过操作设置中断控制器屏蔽某个中断引脚的信号，实现硬件上的中断屏蔽。中断控制器也可以级联提供更多的中断线，具体如下：

![](computer_system/图片/可编程中断控制器.jpg)
如上图，CPU的INTR与中断控制器的INT相连，INTA与ACK相连，当一个外部中断发生时(比如键盘中断IRQ1)，中断控制器与CPU交互操作如下： 
1. IRQ1发生中断，主中断控制器接收到中断信号，检查中断屏蔽寄存器IRQ1是否被屏蔽，如果屏蔽则忽略此中断信号。
2. 将中断控制器中的中断请求寄存器对应的IRQ1位置位，表示收到IRQ1中断。
3. 中断控制器拉高INT引脚电平，告知CPU有中断发生。
4. CPU每执行完一条指令时，都会检查INTR引脚是否被拉高，这里已被拉高。
5. CPU检查EFLAGS寄存器的中断运行标志位IF是否为1，若为1，表明允许中断，通过INTA向中断控制器发出应答。
6. 中断控制器接收到应答信号，将IRQ1的中断向量号发到数据总线上，此时CPU会通过数据总线读取IRQ1的中断向量号。
7. 最后，如果中断控制器需要EOI(End of Interrupt)信号，CPU则会发送，否则中断控制器自动将INT拉低，并清除IRQ1对应的中断请求寄存器位。

### irq_chip结构
在linux内核中，用struct irq_chip结构体描述一个可编程中断控制器，它的整个结构和调度器中的调度类类似，里面定义了中断控制器的一些操作，如下：

```c
struct irq_chip {
    /* 中断控制器的名字 */
    const char    *name;
    /* 控制器初始化函数 */
    unsigned int    (*irq_startup)(struct irq_data *data);
    /* 控制器关闭函数 */
    void        (*irq_shutdown)(struct irq_data *data);
    /* 使能irq操作，通常是直接调用irq_unmask()，通过data参数指明irq */
    void        (*irq_enable)(struct irq_data *data);
    /* 禁止irq操作，通常是直接调用irq_mask，严格意义上，他俩其实代表不同的意义，disable表示中断控制器根本就不响应该irq，而mask时，中断控制器可能响应该irq，只是不通知CPU */
    void        (*irq_disable)(struct irq_data *data);
    /* 用于CPU对该irq的回应，通常表示cpu希望要清除该irq的pending状态，准备接受下一个irq请求 */
    void        (*irq_ack)(struct irq_data *data);
    /* 屏蔽irq操作，通过data参数表明指定irq */
    void        (*irq_mask)(struct irq_data *data);
    /* 相当于irq_mask() + irq_ack() */
    void        (*irq_mask_ack)(struct irq_data *data);
    /* 取消屏蔽指定irq操作 */
    void        (*irq_unmask)(struct irq_data *data);
    /* 某些中断控制器需要在cpu处理完该irq后发出eoi信号 */
    void        (*irq_eoi)(struct irq_data *data);
    /*  用于设置该irq和cpu之间的亲和力，就是通知中断控制器，该irq发生时，那些cpu有权响应该irq */
    int        (*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force);
    int        (*irq_retrigger)(struct irq_data *data);
    /* 设置irq的电气触发条件，例如 IRQ_TYPE_LEVEL_HIGH(电平触发) 或 IRQ_TYPE_EDGE_RISING(边缘触发) */
    int        (*irq_set_type)(struct irq_data *data, unsigned int flow_type);
    /* 通知电源管理子系统，该irq是否可以用作系统的唤醒源 */
    int        (*irq_set_wake)(struct irq_data *data, unsigned int on);

    void        (*irq_bus_lock)(struct irq_data *data);
    void        (*irq_bus_sync_unlock)(struct irq_data *data);

    void        (*irq_cpu_online)(struct irq_data *data);
    void        (*irq_cpu_offline)(struct irq_data *data);

    void        (*irq_suspend)(struct irq_data *data);
    void        (*irq_resume)(struct irq_data *data);
    void        (*irq_pm_shutdown)(struct irq_data *data);

    void        (*irq_calc_mask)(struct irq_data *data);

    void        (*irq_print_chip)(struct irq_data *data, struct seq_file *p);
    int        (*irq_request_resources)(struct irq_data *data);
    void        (*irq_release_resources)(struct irq_data *data);

    unsigned long    flags;
};
```


## 中断向量表(IDT)

每个中断处理程序的==地址==都保存在一个特殊的位置，这个位置被称为 `中断描述符表（Interrupt Descriptor Table）` 或者 `IDT`。处理器使用一个唯一的数字来识别中断和异常的类型，这个数字被称为 `中断标识码（vector number）`。

中断可以分为 ：

* `可屏蔽的（maskable）` 
* `不可屏蔽的（non-maskable）`

异常可以被分为：
- `故障（Faults）`
- `陷入（Traps）`
- `终止（Aborts）`

`故障` 是在执行一个“不完善的”指令（可以在之后被修正）之前被报告的异常。如果发生了，它允许被中断的程序继续执行。

接下来的 `陷入` 是一个在执行了 `陷入` 指令后立刻被报告的异常。陷入同样允许被中断的程序继续执行，就像 `故障` 一样。

最后的 `终止` 是一个从不报告引起异常的精确指令的异常，并且不允许被中断的程序继续执行。


可屏蔽的中断可以被阻塞，使用 `x86_64` 的指令 - `sti` 和 `cli`。我们可以在 Linux 内核代码中找到他们：
```c
static inline void native_irq_disable(void)
{
        asm volatile("cli": : :"memory");
}
```
和：
```c
static inline void native_irq_enable(void)
{
        asm volatile("sti": : :"memory");
}
```

这两个指令修改了在中断寄存器中的 `IF` 标识位。 `sti` 指令设置 `IF` 标识，`cli` 指令清除这个标识。不可屏蔽的中断总是被报告。通常，任何硬件上的失败都映射为不可屏蔽中断。

如果多个异常或者中断同时发生，处理器以事先设定好的中断优先级处理他们。我们可以定义下面表中的从最低到最高的优先级：

| 优先级 (Priority) | 描述 (Description)                                         |
| -------------- | -------------------------------------------------------- |
| 1              | 硬件复位和机器检查 (Hardware Reset and Machine Checks)            |
|                | - RESET                                                  |
|                | - Machine Check                                          |
|                | 任务切换时的陷阱 (Trap on Task Switch)                           |
| 2              | - TSS 中的 T 标志被设置 (T flag in TSS is set)                  |
|                |                                                          |
|                | 外部硬件干预 (External Hardware Interventions)                 |
|                | - FLUSH                                                  |
| 3              | - STOPCLK                                                |
|                | - SMI                                                    |
|                | - INIT                                                   |
|                | 上一条指令的陷阱 (Traps on the Previous Instruction)             |
| 4              | - Breakpoints                                            |
|                | - Debug Trap Exceptions                                  |
| 5              | 不可屏蔽中断 (Nonmaskable Interrupts)                          |
| 6              | 可屏蔽的硬件中断 (Maskable Hardware Interrupts)                  |
| 7              | 代码断点错误 (Code Breakpoint Fault)                           |
| 8              | 从下一条指令获取时的错误 (Faults from Fetching Next Instruction)     |
|                | - 代码段限制违规 (Code-Segment Limit Violation)                 |
|                | - 代码页错误 (Code Page Fault)                                |
|                | 从下一条指令解码时的错误 (Faults from Decoding the Next Instruction) |
|                | - 指令长度超过 15 字节 (Instruction length > 15 bytes)           |
| 9              | - 无效操作码 (Invalid Opcode)                                 |
|                | - 协处理器不可用 (Coprocessor Not Available)                    |
|                |                                                          |
| 10             | 执行指令时的错误 (Faults on Executing an Instruction)            |
|                | - 溢出 (Overflow)                                          |
|                | - 边界错误 (Bound error)                                     |
|                | - 无效 TSS (Invalid TSS)                                   |
|                | - 段不存在 (Segment Not Present)                             |
|                | - 栈错误 (Stack fault)                                      |
|                | - 通用保护错误 (General Protection)                            |
|                | - 数据页错误 (Data Page Fault)                                |
|                | - 对齐检查 (Alignment Check)                                 |
|                | - x87 FPU 浮点异常 (x87 FPU Floating-point exception)        |
|                | - SIMD 浮点异常 (SIMD floating-point exception)              |
|                | - 虚拟化异常 (Virtualization exception)                       |


现在我们了解了一些关于各种类型的中断和异常的内容，是时候转到更实用的部分了。我们从 `中断描述符表（IDT）` 开始。就如之前所提到的，`IDT` 保存了中断和异常处理程序的入口指针。`IDT` 是一个类似于 `全局描述符表（Global Descriptor Table）`的结构.但是他们确实有一些不同，`IDT` 的表项被称为 `门（gates）`，而不是 `描述符（descriptors）`。它可以包含下面的一种：
- 中断门（Interrupt gates）
- 任务门（Task gates）
- 陷阱门（Trap gates）

CPU为了防止恶意程序访问中断，限制了中断门的权限，而在某些时候，用户程序又必须使用中断，所以Linux把中断描述符的中断向量类型改为了5种：**中断门，系统门，系统中断门，陷阱门，任务门**。这个中断向量表的基地址保存在idtr寄存器中。


这个是idt的一般形式：

| Name                                                                                               | Vector nr.        | Type       | Mnemonic | Error code? |
| -------------------------------------------------------------------------------------------------- | ----------------- | ---------- | -------- | ----------- |
| [Division Error](https://wiki.osdev.org/Exceptions#Division_Error)                                 | 0 (0x0)           | Fault      | #DE      | No          |
| [Debug](https://wiki.osdev.org/Exceptions#Debug)                                                   | 1 (0x1)           | Fault/Trap | #DB      | No          |
| [Non-maskable Interrupt](https://wiki.osdev.org/Non_Maskable_Interrupt "Non Maskable Interrupt")   | 2 (0x2)           | Interrupt  | -        | No          |
| [Breakpoint](https://wiki.osdev.org/Exceptions#Breakpoint)                                         | 3 (0x3)           | Trap       | #BP      | No          |
| [Overflow](https://wiki.osdev.org/Exceptions#Overflow)                                             | 4 (0x4)           | Trap       | #OF      | No          |
| [Bound Range Exceeded](https://wiki.osdev.org/Exceptions#Bound_Range_Exceeded)                     | 5 (0x5)           | Fault      | #BR      | No          |
| [Invalid Opcode](https://wiki.osdev.org/Exceptions#Invalid_Opcode)                                 | 6 (0x6)           | Fault      | #UD      | No          |
| [Device Not Available](https://wiki.osdev.org/Exceptions#Device_Not_Available)                     | 7 (0x7)           | Fault      | #NM      | No          |
| [Double Fault](https://wiki.osdev.org/Exceptions#Double_Fault)                                     | 8 (0x8)           | Abort      | #DF      | Yes (Zero)  |
| [Coprocessor Segment Overrun](https://wiki.osdev.org/Exceptions#Coprocessor_Segment_Overrun)       | 9 (0x9)           | Fault      | -        | No          |
| [Invalid TSS](https://wiki.osdev.org/Exceptions#Invalid_TSS)                                       | 10 (0xA)          | Fault      | #TS      | Yes         |
| [Segment Not Present](https://wiki.osdev.org/Exceptions#Segment_Not_Present)                       | 11 (0xB)          | Fault      | #NP      | Yes         |
| [Stack-Segment Fault](https://wiki.osdev.org/Exceptions#Stack-Segment_Fault)                       | 12 (0xC)          | Fault      | #SS      | Yes         |
| [General Protection Fault](https://wiki.osdev.org/Exceptions#General_Protection_Fault)             | 13 (0xD)          | Fault      | #GP      | Yes         |
| [Page Fault](https://wiki.osdev.org/Exceptions#Page_Fault)                                         | 14 (0xE)          | Fault      | #PF      | Yes         |
| Reserved                                                                                           | 15 (0xF)          | -          | -        | No          |
| [x87 Floating-Point Exception](https://wiki.osdev.org/Exceptions#x87_Floating-Point_Exception)     | 16 (0x10)         | Fault      | #MF      | No          |
| [Alignment Check](https://wiki.osdev.org/Exceptions#Alignment_Check)                               | 17 (0x11)         | Fault      | #AC      | Yes         |
| [Machine Check](https://wiki.osdev.org/Exceptions#Machine_Check)                                   | 18 (0x12)         | Abort      | #MC      | No          |
| [SIMD Floating-Point Exception](https://wiki.osdev.org/Exceptions#SIMD_Floating-Point_Exception)   | 19 (0x13)         | Fault      | #XM/#XF  | No          |
| [Virtualization Exception](https://wiki.osdev.org/Exceptions#Virtualization_Exception)             | 20 (0x14)         | Fault      | #VE      | No          |
| [Control Protection Exception](https://wiki.osdev.org/Exceptions#Control_Protection_Exception)     | 21 (0x15)         | Fault      | #CP      | Yes         |
| Reserved                                                                                           | 22-27 (0x16-0x1B) | -          | -        | No          |
| [Hypervisor Injection Exception](https://wiki.osdev.org/Exceptions#Hypervisor_Injection_Exception) | 28 (0x1C)         | Fault      | #HV      | No          |
| [VMM Communication Exception](https://wiki.osdev.org/Exceptions#VMM_Communication_Exception)       | 29 (0x1D)         | Fault      | #VC      | Yes         |
| [Security Exception](https://wiki.osdev.org/Exceptions#Security_Exception)                         | 30 (0x1E)         | Fault      | #SX      | Yes         |
| Reserved                                                                                           | 31 (0x1F)         | -          | -        | No          |
| [Triple Fault](https://wiki.osdev.org/Exceptions#Triple_Fault)                                     | -                 | -          | -        | No          |
| [FPU Error Interrupt](https://wiki.osdev.org/Exceptions#FPU_Error_Interrupt)                       | IRQ 13            | Interrupt  | #FERR    | No          |
我们可以照着这个格式进行初始化：

在 `x86` 架构中，只有 [long mode](http://en.wikipedia.org/wiki/Long_mode) 中断门和陷阱门可以在 `x86_64` 中引用。就像 `全局描述符表`，`中断描述符表` 在 `x86` 上是一个 8 字节数组门，而在 `x86_64` 上是一个 16 字节数组门。与 `全局描述符表` 不一样的是，`中断描述符表` 的第一个元素可以是一个门。它并不是强制要求的。

在 [arch/x86/boot/pm.c](https://github.com/torvalds/linux/blob/master/arch/x86/boot/pm.c)中。`中断描述符表` 可以在线性地址空间和基址的任何地方被加载，只要在 `x86` 上以 8 字节对齐，在 `x86_64` 上以 16 字节对齐。`IDT` 的基址存储在一个特殊的寄存器 - IDTR。在 `x86` 上有两个指令 - 协调工作来修改 `IDTR` 寄存器：
- `LIDT`  ：用来加载 `IDT` 的基址，即在 `IDTR` 的指定操作数。
- `SIDT`  ：用来在指定操作数中读取和存储 `IDTR` 的内容。

```
+-----------------------------------+----------------------+
|                                   |                      |
|     Base address of the IDT       |   Limit of the IDT   |
|                                   |                      |
+-----------------------------------+----------------------+
47                                16 15                    0
```

让我们看看 `setup_idt` 的实现，我们准备了一个 `null_idt`，并且使用 `lidt` 指令把它加载到 `IDTR` 寄存器。注意，`null_idt` 是 `gdt_ptr` 类型，后者定义如下：
```c
struct gdt_ptr {
        u16 len;
        u32 ptr;
} __attribute__((packed));
```

## Gate_Descriptor 

现在，让我们看看 `IDT` 入口结构体，它是一个在 `x86` 中被称为门的 16 字节数组。它拥有下面的结构,Gate Descriptor (64-bit):
```
127                                                                             96
+-------------------------------------------------------------------------------+
|                                                                               |
|                                Reserved                                       |
|                                                                               |
+--------------------------------------------------------------------------------
95                                                                              64
+-------------------------------------------------------------------------------+
|                                                                               |
|                               Offset 63..32                                   |
|                                                                               |
+-------------------------------------------------------------------------------+
63                               48 47      46  44   42    39             34    32
+-------------------------------------------------------------------------------+
|                                  |       |  D  |   |     |      |   |   |     |
|       Offset 31..16              |   P   |  P  | 0 |Type |0 0 0 | 0 | 0 | IST |
|                                  |       |  L  |   |     |      |   |   |     |
 -------------------------------------------------------------------------------+
31                                   16 15                                      0
+-------------------------------------------------------------------------------+
|                                      |                                        |
|          Segment Selector            |                 Offset 15..0           |
|                                      |                                        |
+-------------------------------------------------------------------------------+
```

为了把索引格式化成 IDT 的格式，处理器把异常和中断向量分为 16 个级别。处理器处理异常和中断的发生就像它看到 `call` 指令时处理一个程序调用一样。处理器使用中断或异常的唯一的数字或 `中断标识码` 作为索引来寻找对应的 `中断描述符表` 的条目。现在让我们更近距离地看看 `IDT` 条目。

就像我们所看到的一样，在表中的 `IDT` 条目由下面的域组成：
- `0-15` bits - 段选择器偏移，处理器用它作为中断处理程序的入口指针基址；
- **Offset:** A 64-bit value, split in three parts. It represents the address of the entry point of the **[Interrupt Service Routine](https://wiki.osdev.org/Interrupt_Service_Routines "Interrupt Service Routines")**.
- `16-31` bits - 段选择器基址，包含中断处理程序入口指针；
- **Selector:** A **[Segment Selector](https://wiki.osdev.org/Segment_Selector "Segment Selector")** with multiple fields which must point to a valid code segment in your **[GDT](https://wiki.osdev.org/GDT "GDT")**.
- `IST` - 在 `x86_64` 上的一个新的机制，下面我们会介绍它；
- **IST:** A 3-bit value which is an offset into the **Interrupt Stack Table**, which is stored in the **[Task State Segment](https://wiki.osdev.org/Task_State_Segment "Task State Segment")**. If the bits are all set to zero, the **Interrupt Stack Table** is not used.
- `DPL` - 描述符特权级；
- **DPL:** A 2-bit value which defines the **[CPU Privilege Levels](https://wiki.osdev.org/Security#Rings "Security")** which are allowed to access this interrupt via the **INT** instruction. Hardware interrupts ignore this mechanism.
- `P` - 段存在标志；
- **P:** Present bit. Must be set (**1**) for the descriptor to be valid.
- `48-63` bits - 中断处理程序基址的第二部分；
- `64-95` bits - 中断处理程序基址的第三部分；
- `96-127` bits - CPU 保留位.
- `Type` 域描述了 `IDT` 条目的类型。有三种不同的中断处理程序：
	- 中断门（Interrupt gate）
		**0b1110** 或 **0xE**：64 位中断门
	- 陷入门（Trap gate）
		**0b1111** 或 **0xF**：64 位陷阱门
	- 任务门（Task gate）

`IST` 或者说是 `Interrupt Stack Table` 是 `x86_64` 中的新机制，它用来代替传统的栈切换机制。之前的 `x86` 架构提供的机制可以在响应中断时自动切换栈帧。`IST` 是 `x86` 栈切换模式的一个修改版，在它使能之后可以无条件地切换栈，并且可以被任何与确定中断（我们将在下面介绍它）关联的 `IDT` 条目中的中断使能。从这里可以看出，`IST` 并不是所有的中断必须的，一些中断可以继续使用传统的栈切换模式。`IST` 机制在[任务状态段（Task State Segment）](http://en.wikipedia.org/wiki/Task_state_segment)或者 `TSS` 中提供了 7 个 `IST` 指针。`TSS` 是一个包含进程信息的特殊结构，用来在执行中断或者处理 Linux 内核异常的时候做栈切换。每一个指针都被 `IDT` 中的中断门引用。

`中断描述符表(idt)` 使用 `gate_desc` 的数组描述：

```c
extern gate_desc idt_table[];
```

`gate_desc` 定义如下：

```c
typedef struct gate_struct64 gate_desc;
```

`gate_struct64` 定义如下：

```c
struct gate_struct64 {
        u16 offset_low;
        u16 segment;
        unsigned ist : 3, zero0 : 5, type : 5, dpl : 2, p : 1;
        u16 offset_middle;
        u32 offset_high;
        u32 zero1;
} __attribute__((packed));
```


## 中断处理

当我们发生异常或中断时，系统首先会判断权限字段(安全处理)，权限通过则进入指定的处理函数，而所有的中断门的中断处理函数都是同一个，它首先是一段汇编代码，汇编代码操作如下：

- 执行SAVE_ALL宏，保存**中断向量号**和**寄存器上下文**至当前运行进程的内核栈或者硬中断请求栈(当内核栈大小为8K时保存在内核栈，若为4K，则保存在硬中断请求栈)。
- 调用**do_IRQ()**函数。
- 跳转到ret_from_intr，这是一段汇编代码，主要用于判断是否需要进行调度。


每个能够产生中断的设备或者模块都会在内核中注册一个**中断服务例程(ISR)**，当产生中断时，中断处理程序会被执行，在中断处理程序中，首先会保存中断向量号和上下文，之后执行中断线对应的中断服务例程。对于CPU来说，中断线是非常宝贵的资源，而由于计算机的发展，外部设备数量和种类越来越多，导致了中断线资源不足的情况，linux为了应对这种情况，实现了两种中断线分配方式，分别是：**共享中断线，中断线动态分配**。

* 共享中断线

　　多个设备共用一条中断线，当此条中断线发生中断时，因为不可能预先知道哪个特定的设备产生了中断，因此，这条中断线上的每个中断服务例程都会被执行，以验证是哪个设备产生的中断(一般的，设备产生中断时，会标记自己的状态寄存器，中断服务例程通过检查每个设备的状态寄存器来查找产生中断的设备)。

* 中断线动态分配

　　一条中断线在可能使用的时刻才与一个设备驱动程序关联起来，这样一来，即使几个硬件设备并不共享中断线，同一个中断向量也可以由这几个设备在不同时刻运行。

　共享中断线的分配方式是比较常见的，一次典型的基于共享中断线的中断处理流程如下：
![](computer_system/图片/中断处理过程.jpg)

由于中断处于中断上下文中，所以在中断处理过程中，会有以下几个特性：

- 中断处理程序正在运行时，CPU会通知中断控制器屏蔽产生此中断的中断线。此中断线发出的信号被暂时忽略，当中断处理程序结束时恢复此中断线。
- 在中断服务例程的设计中，原则上是立即处理紧急的操作，将非紧急的操作延后处理(交给软中断进行处理)。
- 中断处理程序是运行在中断上下文，但是其是代表进程运行的，因此它所代表的进行必须处于TASK_RUNNING状态，否则可能出现僵死情况，因此在中断处理程序中不能执行任何阻塞过程。


## 中断描述符

中断描述符用于描述IRQ号的属性与状态，每个IRQ号都有它自己的中断描述符，这些中断描述符用一个数组保存， 这个数组就是**中断描述符表**，整个中断描述符表长度为NR_IRQS（通常为224）项。而当系统中的中断号允许超过224项时， 会用一个radix_tree来组织这些中断描述符， 每次新分配一个IRQ号时， 就会生成对应的中断描述符， 放入radix_tree中。当产生一个中断或者异常时，首先会从中断向量表中获取到一个中断向量号时(此中断向量号有可能表示中断，也可能表示的是一个异常)，如果是一个中断导致的，会执行do_IRQ()函数，而在do_IRQ()函数中，会根据中断向量号，从中断描述符表中获取对应的中断描述符，如下图：
![](computer_system/图片/中断描述符.jpg)

整个中断描述符结构如下：
```c
struct irq_desc {
    struct irq_data        irq_data;
    /* irq的统计信息，在proc中可查到 */
    unsigned int __percpu    *kstat_irqs;
    
    /* 回调函数，当此中断产生中断时，会调用handle_irq，在handle_irq中进行遍历irqaction链表
     * handle_simple_irq  用于简单处理；
     * handle_level_irq  用于电平触发中断的流控处理；
     * handle_edge_irq  用于边沿触发中断的流控处理；
     * handle_fasteoi_irq  用于需要响应eoi的中断控制器；
     * handle_percpu_irq  用于只在单一cpu响应的中断；
     * handle_nested_irq  用于处理使用线程的嵌套中断；
     */
    irq_flow_handler_t    handle_irq;
#ifdef CONFIG_IRQ_PREFLOW_FASTEOI
    irq_preflow_handler_t    preflow_handler;
#endif
    /* 中断服务例程链表 */
    struct irqaction    *action;    /* IRQ action list */
    /* 状态 */
    unsigned int        status_use_accessors;
    /* 函数调用中使用，另一个名称为istate */
    unsigned int        core_internal_state__do_not_mess_with_it;
    /* 嵌套深度，中断线被激活显示0，如果为正数，表示被禁止次数 */
    unsigned int        depth;        /* nested irq disables */
    unsigned int        wake_depth;    /* nested wake enables */
    /* 此中断线上发生的中断次数 */
    unsigned int        irq_count;    /* For detecting broken IRQs */
    /* 上次发生未处理中断时的jiffies值 */
    unsigned long        last_unhandled;    /* Aging timer for unhandled count */
    /* 中断线上无法处理的中断次数，如果当第100000次中断发生时，有超过99900次是意外中断，系统会禁止这条中断线 */
    unsigned int        irqs_unhandled;
    atomic_t        threads_handled;
    int            threads_handled_last;
    /* 锁 */
    raw_spinlock_t        lock;
    struct cpumask        *percpu_enabled;
#ifdef CONFIG_SMP
    /* CPU亲和力关系，其实就是每个CPU是占一个bit长度，某CPU上置为1表明该CPU可以进行这个中断的处理 */
    const struct cpumask    *affinity_hint;
    struct irq_affinity_notify *affinity_notify;
#ifdef CONFIG_GENERIC_PENDING_IRQ
    /* 用于调整irq在各个cpu之间的平衡 */
    cpumask_var_t        pending_mask;
#endif
#endif
    unsigned long        threads_oneshot;
    atomic_t        threads_active;
    /* 用于synchronize_irq()，等待该irq所有线程完成 */
    wait_queue_head_t       wait_for_threads;
#ifdef CONFIG_PM_SLEEP
    /* irqaction数量 */
    unsigned int        nr_actions;
    unsigned int        no_suspend_depth;
    unsigned int        force_resume_depth;
#endif
#ifdef CONFIG_PROC_FS
    /* 指向与IRQn相关的/proc/irq/n目录的描述符 */
    struct proc_dir_entry    *dir;
#endif
    int            parent_irq;
    struct module        *owner;
    /* 在/proc/interrupts所显示名称 */
    const char        *name;
} ____cacheline_internodealigned_in_smp;
```

`core_internal_state__do_not_mess_with_it`成员是用于记录此中断线状态的，中断线状态有如下几种形式：
```c
IRQS_AUTODETECT    　　　　/* 该IRQ线用来进行硬件设备探测 */
    IRQS_SPURIOUS_DISABLED    /* 该IRQ线被禁止，是由于产生了欺骗性中断 */
    IRQS_POLL_INPROGRESS      /* 该IRQ进行轮询检查是否发生中断 */
    IRQS_ONESHOT　　　　　　　　/* 此IRQ没有在主处理函数中进行unmasked处理 */
    IRQS_REPLAY　　　　　　　　 /* IRQ线已被禁止，但前一个出现的中断还没有被应答 */
    IRQS_WAITING　　　　　　　　/* 进行硬件设备探测时，会将所有没有挂载中断服务程序的IRQ线状态设置为IRQS_WAITING，如果该IRQ上有中断产生，就清除这个状态，可以推断哪些引脚产生过中断 */
    IRQS_PENDING　　　　　　　　/* IRQ已经被应答(挂起)，但是内核还没有进行处理 */
    IRQS_SUSPENDED　　　　　　 /* 此IRQ被延迟 */
```

## 中断服务例程(ISR)

　中断服务例程用于描述一个设备的中断处理(区别与中断处理函数)，每个申请了中断的外部设备都会有一个中断服务例程，其作用就是执行对应设备的中断处理。当多个设备共享IRQ线时，内核会将此IRQ线上所有设备的中断服务例程组织成一个链表并保存在中断描述符中，当此IRQ线产生中断时，中断处理函数会依次执行此IRQ线上的中断服务例程。内核使用struct irqaction描述一个中断服务例程：

```c
struct irqaction {
    /* 此中断服务例程的中断处理函数 */
    irq_handler_t        handler;
    /* 设备ID，一般用于指向中断处理时需要的数据结构传入handler */
    void            *dev_id;
    /* 此中断服务例程在CPU上所对应的设备ID */
    void __percpu        *percpu_dev_id;
    /* 链表中下一个中断服务例程 */
    struct irqaction    *next;
    /* 进行中断处理的内核线程执行函数 */
    irq_handler_t        thread_fn;
    /* 一个内核线程，用于执行中断处理 */
    struct task_struct    *thread;
    /* IRQ线，IRQ号 */
    unsigned int        irq;
    unsigned int        flags;
    unsigned long        thread_flags;
    unsigned long        thread_mask;
    const char        *name;
    /* 指向/proc/irq/n目录的描述符 */
    struct proc_dir_entry    *dir;
} ____cacheline_internodealigned_in_smp;
```

## irq_stat数组

此数组包含NR_CPUS个元素，系统中每个CPU对应数组中的一个元素。每个元素的类型为irq_cpustat_t，其包含几个计数器和内核记录CPU正在做什么的标志。

```c
typedef struct {
    unsigned int __softirq_pending;        /* 表示挂起的软中断，每一位表示一个软中断，为1表示挂起 */
    long idle_timestamp;                    /* CPU变为空闲的时间点 */

    /* 硬中断统计. */
    unsigned int irq_timer_count;            /* 定时器中断统计 */
    unsigned int irq_syscall_count;            /* 系统调用中断统计 */
    unsigned int irq_resched_count;        
    unsigned int irq_hv_flush_count;
    unsigned int irq_call_count;
    unsigned int irq_hv_msg_count;
    unsigned int irq_dev_intr_count;

} ____cacheline_aligned irq_cpustat_t;
```


## 关系

**中断描述符(struct irq_desc)，中断控制器描述符(struct irq_chip)，中断服务例程(struct irqaction)**。它们的组织形式如下：
![](computer_system/图片/中断描述符(struct%20irq_desc)，中断控制器描述符(struct%20irq_chip)，中断服务例程(struct%20irqaction)的关系.jpg)


## 深入Linux内核中的中断和异常处理

在 `x86_64` 架构中，每一个活动的线程在 Linux 内核中都有一个很大的栈。这个栈的大小由 `THREAD_SIZE` 定义，而且与下面的定义相等：

```
#define PAGE_SHIFT      12
#define PAGE_SIZE       (_AC(1,UL) << PAGE_SHIFT)
...
...
...
#define THREAD_SIZE_ORDER       (2 + KASAN_STACK_ORDER)
#define THREAD_SIZE  (PAGE_SIZE << THREAD_SIZE_ORDER)
```

`PAGE_SIZE` 是 `4096` 字节，`THREAD_SIZE_ORDER` 的值依赖于 `KASAN_STACK_ORDER`。就像我们看到的，`KASAN_STACK` 依赖于 `CONFIG_KASAN` 内核配置参数，它定义如下：

```
#ifdef CONFIG_KASAN
    #define KASAN_STACK_ORDER 1
#else
    #define KASAN_STACK_ORDER 0
#endif
```

`KASan` 是一个运行时内存[调试器](http://lwn.net/Articles/618180/)。所以，如果 `CONFIG_KASAN` 被禁用，`THREAD_SIZE` 是 `16384` ；如果内核配置选项打开，`THREAD_SIZE` 的值是 `32768`。这块栈空间保存着有用的数据，只要线程是活动状态或者僵尸状态。但是当线程在用户空间的时候，这个内核栈是空的，除非 `thread_info` 结构在这个栈空间的底部。活动的或者僵尸线程并不是在他们栈中的唯一的线程，与每一个 CPU 关联的特殊栈也存在于这个空间。当内核在这个 CPU 上执行代码的时候，这些栈处于活动状态；当在这个 CPU 上执行用户空间代码时，这些栈不包含任何有用的信息。每一个 CPU 也有一个特殊的 per-cpu 栈。首先是给外部中断使用的 `中断栈（interrupt stack）`。它的大小定义如下：

```
#define IRQ_STACK_ORDER (2 + KASAN_STACK_ORDER)
#define IRQ_STACK_SIZE (PAGE_SIZE << IRQ_STACK_ORDER)
```

或者是 `16384` 字节。Per-cpu 的中断栈在 `x86_64` 架构中使用 `irq_stack_union` 联合描述:

```c
union irq_stack_union {
    char irq_stack[IRQ_STACK_SIZE];

    struct {
        char gs_base[40];
        unsigned long stack_canary;
    };
};
```


第一个 `irq_stack` 域是一个 16KB 的数组。然后你可以看到 `irq_stack_union` 联合包含了一个结构体，这个结构体有两个域：
- `gs_base` - 总是指向 `irqstack` 联合底部的 `gs` 寄存器。在 `x86_64` 中， per-cpu 和 stack canary 共享 `gs` 寄存器。所有的 per-cpu 标志初始值为零，并且 `gs` 指向 per-cpu 区域的开始。你已经知道[段内存模式](http://en.wikipedia.org/wiki/Memory_segmentation)已经废除很长时间了，但是我们可以使用[特殊模块寄存器（Model specific registers）](http://en.wikipedia.org/wiki/Model-specific_register)给这两个段寄存器 - `fs` 和 `gs` 设置基址，并且这些寄存器仍然可以被用作地址寄存器。如果你记得 Linux 内核初始程序的第一[部分](http://xinqiu.gitbooks.io/linux-insides-cn/content/Initialization/linux-initialization-1.html)，你会记起我们设置了 `gs` 寄存器：

```
    movl    $MSR_GS_BASE,%ecx
    movl    initial_gs(%rip),%eax
    movl    initial_gs+4(%rip),%edx
    wrmsr
```

`initial_gs` 指向 `irq_stack_union`:

```
GLOBAL(initial_gs)
.quad    INIT_PER_CPU_VAR(irq_stack_union)
```

- `stack_canary` - [Stack canary](http://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries) 对于中断栈来说是一个用来验证栈是否已经被修改的 `栈保护者（stack protector）`。`gs_base` 是一个 40 字节的数组，`GCC` 要求 stack canary 在被修正过的偏移量上，并且 `gs` 的值在 `x86_64` 架构上必须是 `40`，在 `x86` 架构上必须是 `20`。

`irq_stack_union` 是 `percpu` 的第一个数据, 我们可以在 `System.map`中看到它：

```
0000000000000000 D __per_cpu_start
0000000000000000 D irq_stack_union
0000000000004000 d exception_stacks
0000000000009000 D gdt_page
```

我们可以看到它在代码中的定义:

```
DECLARE_PER_CPU_FIRST(union irq_stack_union, irq_stack_union) __visible;
```

现在，是时候来看 `irq_stack_union` 的初始化过程了。除了 `irq_stack_union` 的定义，我们可以在[arch/x86/include/asm/processor.h](https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/processor.h)中查看下面的 per-cpu 变量

```
DECLARE_PER_CPU(char *, irq_stack_ptr);
DECLARE_PER_CPU(unsigned int, irq_count);
```

第一个就是 `irq_stack_ptr`。从这个变量的名字中可以知道，它显然是一个指向这个栈顶的指针。第二个 `irq_count` 用来检查 CPU 是否已经在中断栈。`irq_stack_ptr` 的初始化在[arch/x86/kernel/setup_percpu.c](https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup_percpu.c)的 `setup_per_cpu_areas` 函数中：
```c
void __init setup_per_cpu_areas(void)
{
...
...
#ifdef CONFIG_X86_64
for_each_possible_cpu(cpu) {
    ...
    ...
    ...
    per_cpu(irq_stack_ptr, cpu) =
            per_cpu(irq_stack_union.irq_stack, cpu) +
            IRQ_STACK_SIZE - 64;
    ...
    ...
    ...
#endif
...
...
}
```

现在，我们一个一个查看所有 CPU，并且设置 `irq_stack_ptr`。事实证明它等于中断栈的顶减去 `64`。为什么是 `64`？TODO [[arch/x86/kernel/cpu/common.c](https://github.com/torvalds/linux/blob/master/arch/x86/kernel/cpu/common.c)] 代码如下：
```
void load_percpu_segment(int cpu)
{
        ...
        ...
        ...
        loadsegment(gs, 0);
        wrmsrl(MSR_GS_BASE, (unsigned long)per_cpu(irq_stack_union.gs_base, cpu));
}
```
就像我们所知道的一样，`gs` 寄存器指向中断栈的栈底：
```
movl    $MSR_GS_BASE,%ecx
    movl    initial_gs(%rip),%eax
    movl    initial_gs+4(%rip),%edx
    wrmsr

    GLOBAL(initial_gs)
    .quad    INIT_PER_CPU_VAR(irq_stack_union)
```
现在我们可以看到 `wrmsr` 指令，这个指令从 `edx:eax` 加载数据到 被 `ecx` 指向的[MSR寄存器](https://xinqiu.gitbooks.io/linux-insides-cn/content/Interrupts/(http:/en.wikipedia.org/wiki/Model-specific_register))。在这里MSR寄存器是 `MSR_GS_BASE`，它保存了被 `gs` 寄存器指向的内存段的基址。`edx:eax` 指向 `initial_gs` 的地址，它就是 `irq_stack_union` 的基址。

我们还知道，`x86_64` 有一个叫 `中断栈表（Interrupt Stack Table）` 或者 `IST` 的组件，当发生不可屏蔽中断、双重错误等等的时候，这个组件提供了切换到新栈的功能。这可以到达7个 `IST` per-cpu 入口。其中一些如下; There can be up to seven `IST` entries per-cpu. Some of them are:
- `DOUBLEFAULT_STACK`
- `NMI_STACK`
- `DEBUG_STACK`
- `MCE_STACK`

```
#define DOUBLEFAULT_STACK 1
#define NMI_STACK 2
#define DEBUG_STACK 3
#define MCE_STACK 4
```

所有被 `IST` 切换到新栈的中断门描述符都由 `set_intr_gate_ist` 函数初始化。例如:
```
set_intr_gate_ist(X86_TRAP_NMI, &nmi, NMI_STACK);
...
...
...
set_intr_gate_ist(X86_TRAP_DF, &double_fault, DOUBLEFAULT_STACK);
```

其中 `&nmi` 和 `&double_fault` 是中断函数的入口地址：

```
asmlinkage void nmi(void);
asmlinkage void double_fault(void);
```

定义在 [arch/x86/kernel/entry_64.S](https://github.com/torvalds/linux/blob/master/arch/x86/kernel/entry_64.S)中
```
idtentry double_fault do_double_fault has_error_code=1 paranoid=2
...
...
...
ENTRY(nmi)
...
...
...
END(nmi)
```
当一个中断或者异常发生时，新的 `ss` 选择器被强制置为 `NULL`，并且 `ss` 选择器的 `rpl` 域被设置为新的 `cpl`。旧的 `ss`、`rsp`、寄存器标志、`cs`、`rip` 被压入新栈。在 64 位模型下，中断栈帧大小固定为 8 字节，所以我们可以得到下面的栈:
```
+---------------+
|               |
|      SS       | 40
|      RSP      | 32
|     RFLAGS    | 24
|      CS       | 16
|      RIP      | 8
|   Error code  | 0
|               |
+---------------+
```
如果在中断门中 `IST` 域不是 `0`，我们把 `IST` 读到 `rsp` 中。如果它关联了一个中断向量错误码，我们再把这个错误码压入栈。如果中断向量没有错误码，就继续并且把虚拟错误码压入栈。我们必须做以上的步骤以确保栈一致性。接下来我们从门描述符中加载段选择器域到 CS 寄存器中，并且通过验证第 `21` 位的值来验证目标代码是一个 64 位代码段，例如 `L` 位在 `全局描述符表（Global Descriptor Table）`。最后我们从门描述符中加载偏移域到 `rip` 中，`rip` 是中断处理函数的入口指针。然后中断函数开始执行，在中断函数执行结束后，它必须通过 `iret` 指令把控制权交还给被中断进程。`iret` 指令无条件地弹出栈指针（`ss:rsp`）来恢复被中断的进程，并且不会依赖于 `cpl` 改变。

Linux内核中关于 `x86_64`架构的代码中与中断相关的最早期代码出现在 [arch/x86/boot/pm.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/pm.c)文件中，该文件首次配置了 [中断描述符表](http://en.wikipedia.org/wiki/Interrupt_descriptor_table)(IDT)。对IDT的配置在`go_to_protected_mode`函数中完成，该函数首先调用了 `setup_idt`函数配置了IDT，然后将处理器的工作模式切换为 [保护模式](http://en.wikipedia.org/wiki/Protected_mode):

```C
void go_to_protected_mode(void)
{
        ...
        setup_idt();
        ...
}
```

`setup_idt`函数在同一文件中定义，它仅仅是用 `NULL`填充了中断描述符表:

```
static void setup_idt(void)
{
        static const struct gdt_ptr null_idt = {0, 0};
        asm volatile("lidtl %0" : : "m" (null_idt));
}
```

`gdt_ptr`表示了一个48-bit的特殊功能寄存器 `GDTR`，其包含了全局描述符表 `Global Descriptor`的基地址:
```C
struct gdt_ptr {
        u16 len;
        u32 ptr;
} __attribute__((packed));
```

显然，在此处的 `gdt_prt`不是代表 `GDTR`寄存器而是代表 `IDTR`寄存器，因为我们将其设置到了中断描述符表中。之所以在Linux内核代码中没有`idt_ptr`结构体，是因为其与`gdt_prt`具有相同的结构而仅仅是名字不同，因此没必要定义两个重复的数据结构。可以看到，内核在此处并没有填充`Interrupt Descriptor Table`，这是因为此刻处理任何中断或异常还为时尚早，因此我们仅仅以`NULL`来填充`IDT`。

在设置完 [Interrupt descriptor table](http://en.wikipedia.org/wiki/Interrupt_descriptor_table), [Global Descriptor Table](http://en.wikipedia.org/wiki/GDT)和其他一些东西以后，内核开始进入保护模式，这部分代码在 [arch/x86/boot/pmjump.S](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/pmjump.S)中实现.

进入保护模式的代码位于 `boot_params.hdr.code32_start`，你可以在 [arch/x86/boot/pm.c](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/pm.c)的末尾看到内核将入口函数指针和启动参数 `boot_params`传递给了 `protected_mode_jump`函数:
```c
protected_mode_jump(boot_params.hdr.code32_start,
                            (u32)&boot_params + (ds() << 4));
```

`protected_mode_jump`通过一种[8086](http://en.wikipedia.org/wiki/Intel_8086)的调用 [约定](http://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions)，通过 `ax`和 `dx`两个寄存器来获取参数:
```c
GLOBAL(protected_mode_jump)
        ...
        ...
        ...
        .byte   0x66, 0xea              # ljmpl opcode
2:      .long   in_pm32                 # offset
        .word   __BOOT_CS               # segment
...
...
...
ENDPROC(protected_mode_jump)
```

其中 `in_pm32`包含了对32-bit入口的跳转语句:
`
```c
GLOBAL(in_pm32)
        ...
        ...
        jmpl    *%eax // %eax contains address of the `startup_32`
        ...
        ...
ENDPROC(in_pm32)

```


## 初始化：


而整个初始化的过程与中断处理过程相应，首先先初始化中断向量表，再初始化中断描述符表和中断描述符。中断控制器描述符是系统预定编写好的静态变量，如i8259A中断控制器对应的变量就是i8259A_chip。这时一个中断已经初始化完毕，之后驱动需要使用此中断时系统会将驱动中的中断处理加入到该中断的中断服务例程链表中。如下图
![](computer_system/图片/初始化中断顺序表.jpg)

### 中断api

```c
/* 设置一个中断门
  * n：中断号 
  * addr:中断处理程序入口地址
  */
#define set_intr_gate(n, addr)                        \
    do {                                \
        BUG_ON((unsigned)n > 0xFF);                \
        _set_gate(n, GATE_INTERRUPT, (void *)addr, 0, 0,    \
              __KERNEL_CS);                    \
        _trace_set_gate(n, GATE_INTERRUPT, (void *)trace_##addr,\
                0, 0, __KERNEL_CS);            \
    } while (0)

/* 设置一个系统中断门 */
static inline void set_system_intr_gate(unsigned int n, void *addr)
{
    BUG_ON((unsigned)n > 0xFF);
    _set_gate(n, GATE_INTERRUPT, addr, 0x3, 0, __KERNEL_CS);
}

/* 设置一个系统门 */
static inline void set_system_trap_gate(unsigned int n, void *addr)
{
    BUG_ON((unsigned)n > 0xFF);
    _set_gate(n, GATE_TRAP, addr, 0x3, 0, __KERNEL_CS);
}

/* 设置一个陷阱门 */
static inline void set_trap_gate(unsigned int n, void *addr)
{
    BUG_ON((unsigned)n > 0xFF);
    _set_gate(n, GATE_TRAP, addr, 0, 0, __KERNEL_CS);
}

/* 设置一个任务门 */
static inline void set_task_gate(unsigned int n, unsigned int gdt_entry)
{
    BUG_ON((unsigned)n > 0xFF);
    _set_gate(n, GATE_TASK, (void *)0, 0, 0, (gdt_entry<<3));
}
```
这几个函数用于设置不同门的API函数，他们的参数n都为中断号，而他们都会调用_set_gate()函数，只是参数不同，_set_gate()函数如下：
```c
/* 设置一个门描述符，并写入中断向量表
 * gate: 中断号
 * type: 门类型
 * addr: 中断处理程序入口
 * dpl:  权限位
 * ist:  64位系统才使用
 * seg:  段选择符
 */
static inline void _set_gate(int gate, unsigned type, void *addr,
                 unsigned dpl, unsigned ist, unsigned seg)
{
    gate_desc s;

    /* 生成一个门描述符 */
    pack_gate(&s, type, (unsigned long)addr, dpl, ist, seg);
    /*
     * does not need to be atomic because it is only done once at
     * setup time
     */
    /* 将新的门描述符写入中断向量表中的gate项，使用memcpy进行写入 */
    write_idt_entry(idt_table, gate, &s);
    /* 用于跟踪? 暂时还不清楚这个 trace_idt_table 的用途 */
    write_trace_idt_entry(gate, &s);
}
```
### 初始化中断向量

虽然称之为中断向量表，其实对于CPU来说只是一个起始地址，此地址开始每向上8个字节为一个中断向量。我们的CPU上有一个idtr寄存器，它专门用于保存中断向量表地址，当产生一个中断时，CPU会自动从idtr寄存器保存的中断向量表地址处获取相应的中断向量，然后判断权限并跳转至中断处理函数。当计算机刚启动时，首先会启动引导程序(BIOS)，在BIOS中会把中断向量表存放在内存开始位置(0x00000000)。BIOS会有自己的一些默认中断处理函数，而当BIOS处理完后，会将计算机控制器转交给linux，而linux会在使用BIOS的中断向量表的同时重新设置新的中断向量表(新的地址保存在配置中的CONFIG_VECTORS_BASE)，之后会完全使用新的中断向量表。

一般的，我们也把中断向量表中的中断向量称为**门描述符**，其大小为64位，其主要保存了**段选择符、权限位和中断处理程序入口地址**。CPU主要将门分为三种：**任务门，中断门，陷阱门**。虽然CPU把门描述符分为了三种，但是linux为了处理更多种情况，把门描述符分为了五种，分别为**中断门，系统门，系统中断门，陷阱门，任务门**；但其存储结构与CPU定义的门不变。结构如下：![](#Gate_Descriptor)
门描述符的初始化主要分为两部分，我们知道，中断向量表中保存的是中断和异常，所以整个中断描述符的初始化需要分为中断初始化和异常初始化。而中断向量表的初始化情况是，第一部分是经过一段汇编代码对整个中断向量表进行初始化，第二部分是在系统进入start_kernel()函数后分别对异常和中断进行初始化。在linux中，中断向量表用idt_table[NR_VECTORS]数组进行描述，中断向量(门描述符)在系统中用struct desc_struct结构表示，具体我们可以往下看。
```
__INIT
setup_once:

    movl $idt_table,%edi                           # idt_table就是中断向量表，地址保存到edi中
    movl $early_idt_handlers,%eax                  # early_idt_handlers地址保存到eax中，early_idt_handlers是二维数组，每行9个字符
    movl $NUM_EXCEPTION_VECTORS,%ecx               # NUM_EXCEPTION_VECTORS地址保存到ecx中，ecx用于循环，NUM_EXCEPTION_VECTORS为32
1:
    movl %eax,(%edi)                               # 将eax的值保存到edi保存的地址中
    movl %eax,4(%edi)                              # 将eax的值保存到edi保存的地址+4中
    /* interrupt gate, dpl=0, present */
    movl $(0x8E000000 + __KERNEL_CS),2(%edi)       # 将(0x8E000000 + __KERNEL_CS)一共4个字节保存到edi保存的地址+2的位置中
    addl $9,%eax                                   # eax += 9，指向early_idt_handlers数组下一列
    addl $8,%edi                                   # edi += 8，就是下一个门描述符地址
    loop 1b                                        # 根据ecx是否为0进行循环  
    # 前32个中断向量初始化结果：
    #  |63                         48|47                   32|
	#   31                         16|15                    0|
    #  |early_idt_handlers[i](高16位)|        0x8E00         |     __KERNEL_CS      |early_idt_handlers[i](低16位)|                           

    movl $256 - NUM_EXCEPTION_VECTORS,%ecx         # 256 - 32 保存到ecx，进行新一轮的循环
    movl $ignore_int,%edx                          # ignore_int保存到edx
    movl $(__KERNEL_CS << 16),%eax                 # (__KERNEL_CS << 16)保存到eax
    movw %dx,%ax       
    movw $0x8E00,%dx 2:
    movl %eax,(%edi)
    movl %edx,4(%edi)
    addl $8,%edi                                   # edi += 8，就是下一个门描述符地址
    loop 2b  
    # 其他中断向量初始化结果：
    #  |63                      48|47                   32|31                  16|15                       0|
    #  |    ignore_int(高16位)    |        0x8E00         |     __KERNEL_CS      |    ignore_int(低16位)    |
```

如果CPU是X86，之后会通过 lidt  idt_descr 命令将中断向量表(idt_descr)地址放入idtr寄存器；如果不是，则暂时不会将idt_descr放入idtr寄存器(在trap_init()函数再执行这步操作)。idtr寄存器一共是48位，低16位保存的是中断向量表长度，高32位保存的是中断向量表基地址。我们可以看看idt_descr的形式，如下：
```
idt_descr:
    .word IDT_ENTRIES*8-1        # 这里放入的是表长度， 256 * 8 - 1
    .long idt_table                # idt_table地址放在这，idt_table定义在/arch/x86/kernel/trap.h中

/* 我们再看看 idt_table 是怎么定义的，idt_table代表的就是中断向量表 */
/* 代码地址：arch/x86/kernel/Traps.c */
gate_desc idt_table[NR_VECTORS] __page_aligned_bss;

/* 继续，看看 gate_desc ，用于描述一个中断向量 */
#ifdef CONFIG_X86_64
typedef struct gate_struct64 gate_desc;
#else
typedef struct desc_struct gate_desc;
#endif

/* 我们看看32位下的 struct desc_struct，此结构就是一个中断向量(门描述符)  */
struct desc_struct {
    union {
        struct {
            unsigned int a;
            unsigned int b;
        };
        struct {
            u16 limit0;
            u16 base0;
            unsigned base1: 8, type: 4, s: 1, dpl: 2, p: 1;
            unsigned limit: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;
        };
    };
} __attribute__((packed));
```

可以看出，在汇编代码初始化部分，所有的门描述符的DPL权限位都设置为0(用户态不可访问)，段选择符设置为__KERNEL_CS内核代码段。而对于中断处理函数设置则不同，前32个门描述符的中断处理函数为early_idt_handlers，之后的门描述符的中断处理函数为ignore_int。而在linux中，0~19的中断向量是用于异常和陷阱。20~31的中断向量是intel保留使用的。

### 初始化异常向量

异常向量作为在中断向量表中的前20个向量(0~19)，在汇编代码中已经将其的处理函数设置为early_idt_handlers，而进入start_kernel()函数后，系统会在trap_init()函数中重新设置它们的处理函数，由于异常和陷阱的特殊性，它们并没有像中断这样复杂的数据结构，单纯的，每个异常和陷阱有它们自己的中断处理函数，系统只是简单地把中断处理函数放入异常和陷阱的门描述符中。在了解trap_init()函数之前，我们需要先了解如下几个函数:[中断api](#中断api)

　　了解了以上的设置门描述符的函数，我们再看看trap_init()函数：
```c
void __init trap_init(void)
{
    int i;

/* 使用了EISA总线 */
#ifdef CONFIG_EISA
    void __iomem *p = early_ioremap(0x0FFFD9, 4);

    if (readl(p) == 'E' + ('I'<<8) + ('S'<<16) + ('A'<<24))
        EISA_bus = 1;
    early_iounmap(p, 4);
#endif

/* Interrupts/Exceptions */
//enum {
//    X86_TRAP_DE = 0,    /*  0, 除0操作 Divide-by-zero */
//    X86_TRAP_DB,        /*  1, 调试使用 Debug */
//    X86_TRAP_NMI,        /*  2, 非屏蔽中断 Non-maskable Interrupt */
//    X86_TRAP_BP,        /*  3, 断点 Breakpoint */
//    X86_TRAP_OF,        /*  4, 溢出 Overflow */
//    X86_TRAP_BR,        /*  5, 越界异常 Bound Range Exceeded */
//    X86_TRAP_UD,        /*  6, 无效操作码 Invalid Opcode */
//    X86_TRAP_NM,        /*  7, 无效设备 Device Not Available */
//    X86_TRAP_DF,        /*  8, 双重故障 Double Fault */
//    X86_TRAP_OLD_MF,    /*  9, 协处理器段超限 Coprocessor Segment Overrun */
//    X86_TRAP_TS,        /* 10, 无效任务状态段(TSS) Invalid TSS */
//    X86_TRAP_NP,        /* 11, 段不存在 Segment Not Present */
//    X86_TRAP_SS,        /* 12, 栈段错误 Stack Segment Fault */
//    X86_TRAP_GP,        /* 13, 保护错误 General Protection Fault */
//    X86_TRAP_PF,        /* 14, 页错误 Page Fault */
//    X86_TRAP_SPURIOUS,    /* 15, 欺骗性中断 Spurious Interrupt */
//    X86_TRAP_MF,        /* 16, X87 浮点数异常 Floating-Point Exception */
//    X86_TRAP_AC,        /* 17, 对齐检查 Alignment Check */
//    X86_TRAP_MC,        /* 18, 设备检查 Machine Check */
//    X86_TRAP_XF,        /* 19, SIMD 浮点数异常 Floating-Point Exception */
//    X86_TRAP_IRET = 32,    /* 32, 汇编指令异常 IRET Exception */
//};

    set_intr_gate(X86_TRAP_DE, divide_error);
    /* 在32位系统上其效果等同于 set_intr_gate  */
    set_intr_gate_ist(X86_TRAP_NMI, &nmi, NMI_STACK);
    /* int4 can be called from all */
    set_system_intr_gate(X86_TRAP_OF, &overflow);
    set_intr_gate(X86_TRAP_BR, bounds);
    set_intr_gate(X86_TRAP_UD, invalid_op);
    set_intr_gate(X86_TRAP_NM, device_not_available);
#ifdef CONFIG_X86_32
    set_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);
#else
    set_intr_gate_ist(X86_TRAP_DF, &double_fault, DOUBLEFAULT_STACK);
#endif
    set_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);
    set_intr_gate(X86_TRAP_TS, invalid_TSS);
    set_intr_gate(X86_TRAP_NP, segment_not_present);
    set_intr_gate(X86_TRAP_SS, stack_segment);
    set_intr_gate(X86_TRAP_GP, general_protection);
    set_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);
    set_intr_gate(X86_TRAP_MF, coprocessor_error);
    set_intr_gate(X86_TRAP_AC, alignment_check);
#ifdef CONFIG_X86_MCE
    set_intr_gate_ist(X86_TRAP_MC, &machine_check, MCE_STACK);
#endif
    set_intr_gate(X86_TRAP_XF, simd_coprocessor_error);

    /* 将前32个中断号都设置为已使用状态 */
    for (i = 0; i < FIRST_EXTERNAL_VECTOR; i++)
        set_bit(i, used_vectors);

#ifdef CONFIG_IA32_EMULATION
    /* 设置0x80系统调用的系统中断门 */
    set_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);
    set_bit(IA32_SYSCALL_VECTOR, used_vectors);
#endif

#ifdef CONFIG_X86_32
    /* 设置0x80系统调用的系统门 */
    set_system_trap_gate(SYSCALL_VECTOR, &system_call);
    set_bit(SYSCALL_VECTOR, used_vectors);
#endif

    /*
     * Set the IDT descriptor to a fixed read-only location, so that the
     * "sidt" instruction will not leak the location of the kernel, and
     * to defend the IDT against arbitrary memory write vulnerabilities.
     * It will be reloaded in cpu_init() */
    /* 将中断向量表设置在一个固定的只读的位置,以便“sidt”指令不会泄漏内核的位置,和保护中断向量表可以处于任意内存写的漏洞。它将会在 cpu_init() 中被加载到idtr寄存器 */
    __set_fixmap(FIX_RO_IDT, __pa_symbol(idt_table), PAGE_KERNEL_RO);
    idt_descr.address = fix_to_virt(FIX_RO_IDT);

    /* 执行CPU的初始化，对于中断而言，在 cpu_init() 中主要是将 idt_descr 放入idtr寄存器中 */
    cpu_init();

    /* x86_init是一个定义了很多x86体系上的初始化操作，这里执行的另一个trap_init()函数为空函数，什么都不做 */
    x86_init.irqs.trap_init();

#ifdef CONFIG_X86_64
    /* 64位操作 */
    /* 将 idt_table 复制到 debug_idt_table 中 */
    memcpy(&debug_idt_table, &idt_table, IDT_ENTRIES * 16);
    set_nmi_gate(X86_TRAP_DB, &debug);
    set_nmi_gate(X86_TRAP_BP, &int3);
#endif
}
```

在代码中，used_vectors变量是一个bitmap，它用于记录中断向量表中哪些中断已经被系统注册和使用，哪些未被注册使用。trap_init()已经完成了异常和陷阱的初始化。对于linux而言，中断号0~19是专门用于陷阱和故障使用的，以上代码也表明了这一点，而20~31一般是intel用于保留的。而我们的外部IRQ线使用的中断为32~255(代码中32号中断被用作汇编指令异常中断)。所以，在trap_init()代码中，专门对0~19号中断的门描述符进行了初始化，最后将新的中断向量表起始地址放入idtr寄存器中。在trap_init()中我们看到每个异常和陷阱都有他们自己的处理函数，不过它们的处理函数的处理方式都大同小异，如下：
```c
#代码地址：arch/x86/kernel/entry_32.S

# 11号异常处理函数入口
ENTRY(segment_not_present)
    RING0_EC_FRAME
    ASM_CLAC
    pushl_cfi $do_segment_not_present
    jmp error_code
    CFI_ENDPROC
END(segment_not_present)

# 12号异常处理函数入口
ENTRY(stack_segment)
    RING0_EC_FRAME
    ASM_CLAC
    pushl_cfi $do_stack_segment
    jmp error_code
    CFI_ENDPROC
END(stack_segment)

# 17号异常处理函数入口
ENTRY(alignment_check)
    RING0_EC_FRAME
    ASM_CLAC
    pushl_cfi $do_alignment_check
    jmp error_code
    CFI_ENDPROC
END(alignment_check)

# 0号异常处理函数入口
ENTRY(divide_error)
    RING0_INT_FRAME
    ASM_CLAC
    pushl_cfi $0            # no error code
    pushl_cfi $do_divide_error
    jmp error_code
    CFI_ENDPROC
END(divide_error)
```

在trap_init()函数中调用了cpu_init()函数，在此函数中会将新的中断向量表地址放入idtr寄存器中，而具体内核是如何实现的呢，之前已经说明，idtr寄存器的低16位保存的是中断向量表长度，高32位保存的是中断向量表基地址，相对于的，内核定义了一个struct desc_ptr结构专门用于保存idtr寄存器内容，其如下：
```
/* 代码地址：arch/x86/include/asm/Desc_defs.h */
struct desc_ptr {
    unsigned short size;
    unsigned long address;
} __attribute__((packed)) ;

/* 代码地址：arch/x86/kernel/cpu/Common.c */
/* 专门用于保存需要写入idtr寄存器值的变量，这里可以看出，中断向量表长度为256 * 16 - 1，地址为idt_table */
struct desc_ptr idt_descr = { NR_VECTORS * 16 - 1, (unsigned long) idt_table };
```
在cpu_init()中，会调用load_current_idt()函数进行写入，如下：
```c
static inline void load_current_idt(void)
{
    if (is_debug_idt_enabled())
        /* 开启了中断调试，用的是 debug_idt_descr 和 debug_idt_table */
        load_debug_idt();
    else if (is_trace_idt_enabled())
        /* 开启了中断跟踪，用的是 trace_idt_descr 和 trace_idt_table */
        load_trace_idt();
    else
        /* 普通情况，用的是 idt_descr 和 idt_table */
        load_idt((const struct desc_ptr *)&idt_descr);
}

/* load_idt()的定义 */
#define load_idt(dtr)                native_load_idt(dtr)

/* native_load_idt()的定义 */
static inline void native_load_idt(const struct desc_ptr *dtr)
{
    asm volatile("lidt %0"::"m" (*dtr));
}
```

### 初始化中断

内核是在异常和陷阱初始化完成的情况下才会进行中断的初始化，中断的初始化也是处于start_kernel()函数中，分为两个部分，分别是early_irq_init()和init_IRQ()。early_irq_init()是第一步的初始化，其工作主要是跟硬件无关的一些初始化，比如一些变量的初始化，分配必要的内存等。init_IRQ()是第二步，其主要就是关于硬件部分的初始化了。

　　首先我们先看看中断描述符表irq_desc[NR_IRQS]：
```c
/* 中断描述符表 */
struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
    [0 ... NR_IRQS-1] = {
        .handle_irq    = handle_bad_irq,
        .depth        = 1,
        .lock        = __RAW_SPIN_LOCK_UNLOCKED(irq_desc->lock),
    }
};
```

可以看到，irq_desc数组有NR_IRQS个元素，NR_IRQS并不是256-32，实际上，虽然中断向量表中一共有256项(前32项用作异常和intel保留)，但并不是所有中断向量都会使用到，所以中断描述符表也不一定是256-32项，CPU可以使用多少个中断是由中断控制器(PIC、APIC)或者内核配置决定的，我们看看NR_IRQS的定义：

```
/* IOAPIC为外部中断控制器 */
#ifdef CONFIG_X86_IO_APIC
#define CPU_VECTOR_LIMIT        (64 * NR_CPUS)
#define NR_IRQS                    \
    (CPU_VECTOR_LIMIT > IO_APIC_VECTOR_LIMIT ?    \
        (NR_VECTORS + CPU_VECTOR_LIMIT)  :    \
        (NR_VECTORS + IO_APIC_VECTOR_LIMIT))
#else /* !CONFIG_X86_IO_APIC: NR_IRQS_LEGACY = 16 */
#define NR_IRQS            NR_IRQS_LEGACY
#endif
```

这时我们可以先看看early_irq_init()函数：

```c
int __init early_irq_init(void)
{
    int count, i, node = first_online_node;
    struct irq_desc *desc;

    /* 初始化irq_default_affinity变量，此变量用于设置中断默认的CPU亲和力 */
    init_irq_default_affinity();

    printk(KERN_INFO "NR_IRQS:%d\n", NR_IRQS);

    /* 指向中断描述符表irq_desc */
    desc = irq_desc;
    /* 获取中断描述符表长度 */
    count = ARRAY_SIZE(irq_desc);

    for (i = 0; i < count; i++) {
        /* 为kstat_irqs分配内存，每个CPU有自己独有的kstat_irqs数据，此数据用于统计 */
        desc[i].kstat_irqs = alloc_percpu(unsigned int);
        /* 为 desc->irq_data.affinity 和 desc->pending_mask 分配内存 */
        alloc_masks(&desc[i], GFP_KERNEL, node);
        /* 初始化中断描述符的锁 */
        raw_spin_lock_init(&desc[i].lock);
        /* 设置中断描述符的锁所属的类，此类用于防止死锁 */
        lockdep_set_class(&desc[i].lock, &irq_desc_lock_class);
        /* 一些变量的初始化 */
        desc_set_defaults(i, &desc[i], node, NULL);
    }

    return arch_early_irq_init();
}
```

更多的初始化在desc_set_defaults()函数中：
```c
static void desc_set_defaults(unsigned int irq, struct irq_desc *desc, int node,
        struct module *owner)
{
    int cpu;

    /* 中断号 */
    desc->irq_data.irq = irq;
    /* 中断描述符的中断控制器芯片为 no_irq_chip  */
    desc->irq_data.chip = &no_irq_chip;
    /* 中断控制器的私有数据为空 */
    desc->irq_data.chip_data = NULL;
    desc->irq_data.handler_data = NULL;
    desc->irq_data.msi_desc = NULL;
    /* 设置中断状态 desc->status_use_accessors 为初始化状态_IRQ_DEFAULT_INIT_FLAGS */
    irq_settings_clr_and_set(desc, ~0, _IRQ_DEFAULT_INIT_FLAGS);
    /* 中断默认被禁止，设置 desc->irq_data->state_use_accessors = IRQD_IRQ_DISABLED */
    irqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);
    /* 设置中断处理回调函数为 handle_bad_irq，handle_bad_irq作为默认的回调函数，此函数中基本上不做什么处理，就是在屏幕上打印此中断信息，并且desc->kstat_irqs++ */
    desc->handle_irq = handle_bad_irq;
    /* 嵌套深度为1，表示被禁止1次 */
    desc->depth = 1;
    /* 初始化此中断发送次数为0 */
    desc->irq_count = 0;
    /* 无法处理的中断次数为0 */
    desc->irqs_unhandled = 0;
    /* 在/proc/interrupts所显名字为空 */
    desc->name = NULL;
    /* owner为空 */
    desc->owner = owner;
    
    /* 初始化kstat_irqs中每个CPU项都为0 */
    for_each_possible_cpu(cpu)
        *per_cpu_ptr(desc->kstat_irqs, cpu) = 0;
    
    /* SMP系统才使用的初始化，设置
     * desc->irq_data.node = first_online_node 
     * desc->irq_data.affinity = irq_default_affinity
     * 清除desc->pending_mask
     */
    desc_smp_init(desc, node);
}
```

整个early_irq_init()在这里就初始化完毕了，相对来说比较简单，可以说early_irq_init()只是初始化了中断描述符表中的所有元素。

在看init_IRQ()前需要看看legacy_pic这个变量，它其实就是CPU内部的中断控制器i8259A，定义了与i8259A相关的一些处理函数和中断数量，如下：

```c
struct legacy_pic default_legacy_pic = {
    .nr_legacy_irqs = NR_IRQS_LEGACY,
    .chip  = &i8259A_chip,
    .mask = mask_8259A_irq,
    .unmask = unmask_8259A_irq,
    .mask_all = mask_8259A,
    .restore_mask = unmask_8259A,
    .init = init_8259A,
    .irq_pending = i8259A_irq_pending,
    .make_irq = make_8259A_irq,
};

struct legacy_pic *legacy_pic = &default_legacy_pic;
```

在X86体系下，CPU使用的内部中断控制器是i8259A，内核就定义了这个变量进行使用，在init_IRQ()中会将所有的中断描述符的中断控制器芯片指向i8259A，具体我们先看看init_IRQ()代码：

```
void __init init_IRQ(void)
{
    int i;

    /*
     * On cpu 0, Assign IRQ0_VECTOR..IRQ15_VECTOR's to IRQ 0..15.
     * If these IRQ's are handled by legacy interrupt-controllers like PIC,
     * then this configuration will likely be static after the boot. If
     * these IRQ's are handled by more mordern controllers like IO-APIC,
     * then this vector space can be freed and re-used dynamically as the
     * irq's migrate etc.
     */
    /* nr_legacy_irqs() 返回 legacy_pic->nr_legacy_irqs，为16
     * vector_irq是一个int型的数组，长度为中断向量表长，其保存的是中断向量对应的中断号(如果中断向量是异常则没有中断号)
     * i8259A中断控制器使用IRQ0~IRQ15这16个中断号，这里将这16个中断号设置到CPU0的vector_irq数组的0x30~0x3f上。
     */
    for (i = 0; i < nr_legacy_irqs(); i++)
        per_cpu(vector_irq, 0)[IRQ0_VECTOR + i] = i;

    /* x86_init是一个结构体，里面定义了一组X86体系下的初始化函数 */
    x86_init.irqs.intr_init();
}
```

x86_init.irqs.intr_init()是一个函数指针，其指向native_init_IRQ()，我们可以直接看看native_init_IRQ()：
```c
void __init native_init_IRQ(void)
{
    int i;

    /* Execute any quirks before the call gates are initialised: */
    /* 这里又是执行x86_init结构中的初始化函数，pre_vector_init()指向 init_ISA_irqs  */
    x86_init.irqs.pre_vector_init();

    /* 初始化中断向量表中的中断控制器中默认的一些中断门初始化 */
    apic_intr_init();

    /*
     * Cover the whole vector space, no vector can escape
     * us. (some of these will be overridden and become
     * 'special' SMP interrupts)
     */
    /* 第一个外部中断，默认是32 */
    i = FIRST_EXTERNAL_VECTOR;
    /* 在used_vectors变量中找出所有没有置位的中断向量，我们知道，在trap_init()中对所有异常和陷阱和系统调用中断都置位了used_vectors，没有置位的都为中断
     * 这里就是对所有中断设置门描述符
     */
    for_each_clear_bit_from(i, used_vectors, NR_VECTORS) {
        /* IA32_SYSCALL_VECTOR could be used in trap_init already. */
        /* interrupt[]数组保存的是外部中断的中断门信息
         * 这里将中断向量表中空闲的中断向量设置为中断门,interrupt是一个函数指针数组，其将31~255数组元素指向interrupt[i]函数
         */
        set_intr_gate(i, interrupt[i - FIRST_EXTERNAL_VECTOR]);
    }

    /* 如果外部中断控制器需要，则安装一个中断处理例程irq2到中断IRQ2上 */
    if (!acpi_ioapic && !of_ioapic && nr_legacy_irqs())
        setup_irq(2, &irq2);

#ifdef CONFIG_X86_32
    /* 在x86_32模式下，会为当前CPU分配一个中断使用的栈空间 */
    irq_ctx_init(smp_processor_id());
#endif
}
```

在native_init_IRQ()中，又使用了x86_init变量中的pre_vector_init函数指针，其指向init_ISA_irqs()函数：
```c
void __init init_ISA_irqs(void)
{
    /* CHIP默认是i8259A_chip */
    struct irq_chip *chip = legacy_pic->chip;
    int i;

#if defined(CONFIG_X86_64) || defined(CONFIG_X86_LOCAL_APIC)
    /* 使用了CPU本地中断控制器 */
    /* 开启virtual wire mode */
    init_bsp_APIC();
#endif
    /* 其实就是调用init_8259A()，进行8259A硬件的初始化 */
    legacy_pic->init(0);

    for (i = 0; i < nr_legacy_irqs(); i++)
        /* i为中断号，chip是irq_chip结构，最后是中断回调函数 
         * 设置了中断号i的中断描述符的irq_data.irq_chip = i8259A_chip
         * 设置了中断回调函数为handle_level_irq
         */
        irq_set_chip_and_handler(i, chip, handle_level_irq);
}
```

在init_ISA_irqs()函数中，最主要的就是将内核使用的外部中断的中断描述符的中断控制器设置为i8259A_chip，中断回调函数为handle_level_irq。

回到native_init_IRQ()函数，当执行完x86_init.irqs.pre_vector_init()之后，会执行apic_initr_init()函数，这个函数中会初始化一些中断控制器特定的中断函数(这些中断游离于之前描述的中断体系中，它们没有自己的中断描述符，中断向量中直接保存它们自己的中断处理函数，类似于异常与陷阱的调用情况)，具体我们看看：
```c
static void __init apic_intr_init(void)
{
    smp_intr_init();

#ifdef CONFIG_X86_THERMAL_VECTOR
    /* 中断号为: 0xfa，处理函数为: thermal_interrupt */
    alloc_intr_gate(THERMAL_APIC_VECTOR, thermal_interrupt);
#endif
#ifdef CONFIG_X86_MCE_THRESHOLD
    alloc_intr_gate(THRESHOLD_APIC_VECTOR, threshold_interrupt);
#endif

#if defined(CONFIG_X86_64) || defined(CONFIG_X86_LOCAL_APIC)
    /* self generated IPI for local APIC timer */
    alloc_intr_gate(LOCAL_TIMER_VECTOR, apic_timer_interrupt);

    /* IPI for X86 platform specific use */
    alloc_intr_gate(X86_PLATFORM_IPI_VECTOR, x86_platform_ipi);
#ifdef CONFIG_HAVE_KVM
    /* IPI for KVM to deliver posted interrupt */
    alloc_intr_gate(POSTED_INTR_VECTOR, kvm_posted_intr_ipi);
#endif

    /* IPI vectors for APIC spurious and error interrupts */
    alloc_intr_gate(SPURIOUS_APIC_VECTOR, spurious_interrupt);
    alloc_intr_gate(ERROR_APIC_VECTOR, error_interrupt);

    /* IRQ work interrupts: */
# ifdef CONFIG_IRQ_WORK
    alloc_intr_gate(IRQ_WORK_VECTOR, irq_work_interrupt);
# endif

#endif
}
```

在apic_intr_init()函数中，使用了alloc_intr_gate()函数进行处理，这个函数的处理也很简单，置位该中断号所处used_vectors位置，调用set_intr_gate()设置一个中断门描述符。
到这里整个中断及异常都已经初始化完成了。


###  总结

- 在linux系统中，中断一共有256个，0~19主要用于异常与陷阱，20~31是intel保留，未使用。32~255作为外部中断进行使用。特别的，0x80中断用于系统调用。
- 机器上电时，BIOS会初始化一个中断向量表，当交接给linux内核后，内核会自己新建立一个中断向量表，之后完全使用自己的中断向量表，舍弃BIOS的中断向量表。
- 在x86上系统默认使用的中断控制器为i8259A。
- 中断描述符的初始化过程中，内核会将中断描述符的默认中断控制器设置为i8259A，中断处理回调函数为handle_level_irq()。
- 外部中断的门描述的中断处理函数都为interrupt[i]。


中断的初始化大体上分为两个部分，第一个部分为汇编代码的中断向量表的初次初始化，第二部分为C语言代码，其又分为异常与陷阱的初始化和中断的初始化。如图：
![](computer_system/图片/中断汇编与c语言.jpg)

* 在汇编的中断向量表初始化过中，其主要对整个中断向量表进行了初始化，其主要工作是：
	- 所有的门描述符的权限位为0;
	- 所有的门描述符的段选择符为__KERNEL_CS;
	- 0~31的门描述符的中断处理程序为early_idt_handlers[i](0 <= i <= 31);
	- 其他的门描述符的中断处理程序为ignore_int
- 而trap_init()所做的异常与陷阱初始化，就是修改中断向量表的前19项(异常和中断)，主要修改他们的中断处理函数入口和权限位，特殊的如任务门还会设置它们的段选择符。在trap_init()中就已经把所有的异常和陷阱都初始化完成了，并会把新的中断向量表地址放入idtr寄存器，开始使用新的中断向量表。
- 在early_irq_init()中，主要工作是初始化整个中断描述符表，将数组中的每个中断描述符中的必要变量进行初始化。
- 最后在init_IRQ()中，主要工作是初始化中断向量表中的所有中断门描述符，对于一般的中断，内核将它们的中断处理函数入口设置为interrupt[i]，而一些特殊的中断会在apic_intr_init()中进行设置。之后，init_IRQ()会初始化内部和外部的中断控制器，最后将一般的中断使用的中断控制器设置为i8259A，中断处理函数为handle_level_irq(电平触发)。
